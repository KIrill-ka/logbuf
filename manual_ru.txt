Библиотека протоколирования событий logbuf

1. Составные части

1.1 logbuf (log buffer)
Содержит функции для сбора информации о событии и упаковки
этой информации. После упаковки параметры сообщения доступны по отдельности
то есть пригодны и для форматирования в читаемую пользователем строку и для
автоматического анализа/реации на событие.

1.2 logcounter (log counter)
Фильтрует сообщения на самом низком уровне,
обеспечивает передачу сообщений по одному или нескольким каналам.

1.3 logdest (log destination)
Вспомогательная библиотека для реализации способов доставки сообщений пользователю.
Включает функции форматирования сообщений из данных logbuf в читаемую строку.

1.4 logres (log resources)
Получение строк по идентификатору ресурса. Могут быть получены строки
для форматирования сообщений.

                       +-> LOGDEST1 --> SYSLOG
                      /
LOGBUF <-> LOGCOUNTER --> LOGDEST2 --> STDIO
                      \
                       +-> LOGDEST3 --> FILE
                             ^
                             |
                           LOGRES

2. Сценарии спользования

2.1 Простейшая схема использования почти не отличается от вывода сообщений в stdio.
Форматная строка непосредственно встраивается в сообщение, описывается 
простейший способ вывода сообщений в stdio. Ресурсы не используется.
Пример в test/logtest.c
Его можно еще немного упростить, если вместо раздельной передачи
параметров сообщения использовать logbuf_simple_message.

2.2 Использование ресурсов. К примеру 2.1 добавляем описание ресурсов -
форматная строка сообщения теперь содержится не в тексте программы, а в
ini-файле. В примере test/logtest-res.c для упрощения текст ini-файла
включен в текст программы. В качестве идентификатора ресурса используется 1.
При реальном использовании константы-идентификаторы ресурсов в формате #define 
могут быть получены с помощью скрипта scripts/ini2resid.awk

awk -f scripts/ini2resid.awk -v name=имя_заголовка имя_файла_ini > имя_заголовка

3. Основные особенности и свойства библиотек logbuf

Простота начального использования: если в программе потенциально может
понадобиться протоколирование событий, но пока достаточно только вывода
в stdio, библиотеки logbuf могут быть использованы. Далее, например,
при необходимости вывода сообщений в syslog или через GUI потребуются
минимальные переделки (в идеале код формирующий сообщения вообще не потребует
изменений). Форматные строки, добавляемые при формировании сообщения, 
могут быть заменены ресурсами. При этом оригинальные строки удалять не надо,
они просто перестанут использоваться.

Маска событий и фильтрация на нижнем уровне: при большой интенсивности
событий небоходима возможность оключения протоколирования. При отключенном
логе должно выполняться как можно меньше действий по формированию сообщений.
Это достигается путем задания маски сообщений. В logcounter задается 64-битная
маска, которая позволяет разбить сообщения на 64 группы, каждую из которых
можно индивидуально оключить. Маска задается индивидуально для каждого
канала передачи (log destination). Если ни для одного канала не требуются
сообщения какой-то группы, то формирования сообщения не начнется (logbuf_get
вернет NULL).
Источник сообщений может задать маску по-умолчанию (logcounter_set_default_filter) 
на случай, если получатель событий не знает, как управлять событиями из этого источника.

"Модульное" использование: если программа состоит из нескольких компонент/библиотек -
каждая из них создает свой logcounter. Далее библиотека предоставляет в своем
интерфейсе доступ к этому logcounter. Основная программа при старте связывает 
logcounter библиотек и получателей сообщений.
Файлы ресурсов могут быть разделены - ini-файл хранится рядом с кодом библиотеки.
Идентификаторы ресурсов должны быть уникальными - для этого старшие 12 бит кода
ресурса являются идентификатором модуля/библиотеки.
При сборке дистрибутива ini-файлы всех модулей моут быть объединены или включены
в дистрибутив и подгружены по-отдельности.

Timestamp: в logcounter предусмотрена функция задания временной метки для
события. Т.е. в каждом сообщении отмечается время его формирования. Это
может быть использовано для диагностики проблем, связанных с производительностью.
См. logcounter_tstamp_onoff.

4. log_stdio

log_stdio - готовый способ вывода сообщений в файлы stdio.
Например, чтобы сделать традиционный вывод в stderr и stdout, нужно
создать два экземпляра logdest:

log_err = logdest_stdio_create(stderr, NULL);
log_norm = logdest_stdio_create(stdout, NULL);

logcounter_connect(lc, log_err);
logcounter_connect(lc, log_norm);
logcounter_set_filter(lc, log_err, <error_mask>);
logcounter_set_filter(lc, log_norm, ~ <error_mask>);

5. Форматные строки

Строка формата logbuf похоже на строку printf, но отличается тем, что подстановка параметров не происходит непосредственно 
на месте формирования сообщения. Когда параметры помещаются в сообщение, они содержат информацию о типе данных. Поэтому, например,
в строке формата не указывается размер целого числа (32/64), а это определяется по типу параметра.

5.1 Типы данных (dtype) - это то, что содержится в буфере до форматирования.
D - int64
s - string (char*)
S - format string (char*)
b - data buffer
d - int32
R - int32 - идентификатор ресурса

5.2 Форматы (после знака %)
d,x,u,X - целые числа, аналогично printf %d, %x, %u.
        Допустимые типы данных: D, d
        Для этих типов можно указывать следующие модификаторы форматирования.
        <число> - количество позиций, занимаемое числом, если число начинается с 0, то
                  пустое место заполняется нулями, иначе - пробелами.
        + - для x и X добавляет "0x" перед числом
        l - указывает, что это 64-битное значение. Непосредственно при форматировании это не используется, но для
            коротких форм (logbuf_simple_message, lobuf_debug, logbuf_fmtauto_va, logbuf_fmtauto) это необходимо для правильной
            интерпретации параметров.
        Примеры:
        код формата     параметр     результат
        %+02x           15           "0x0f" 
        %+02x           256          "0x100"
        %3d             10           " 10"       
a - IP-адрес.
        Допустимые типы данных: d
e - ethernet-адрес
        Допустимые типы данных: b (6 байт).
% - %
,<width><fmt> - массив данных (печатаются значения через пробел).
        Допустимые типы данных: b.
        <width> - размер элемента в байтах (1-8). Если <width> опущено, то 4.
        <fmt> - формат X,d,x,u,a. Если a - то <width> должно быть 4.
        Для чисел можно использовать модификаторы (см. d,x,u,X), указывать их нужно перед запятой. 
        Напрмер, сложный вариант "%#5#04,2x": здесь 5 - номер параметра, 04 - вывод в формате 0x0000, 2 байта - размер числа в массиве.
n - инорировать параметр
s - строка
        Допустимые типы данных: s, R
S - вложенная форматная строка (максимальный уровень вложенности 8)
        Допустимые типы данных: S, R
#<argn><fmt> - фиксированный номер параметра (<argn>)
        <fmt> - любой формат из описанных выше
        Допускается конструкция #<argn>#<fmt>, тогда <fmt> может начинаться с цифры.
(<dtype>, (<argn><dtype> - условное форматирование. Если есть <argn> и его тип соответствует <dtype>, включается строка следующая
        после <dtype> до %). Вложение условий допускается.
        <argn> -  номер параметра для проверки. Если номер не указан, используется автонумерация.
        <dtype>  - тип данных (описаны выше). Если указана *, проверка на соответствие типа не производится,
        достаточно наличия аргумента.
| - используется как "else" в конструкции %( %| %). Если проверка %( не сработала, то включается строка, идущая между %| и %).

5.3 Автоматическая нумерация параметров
Нумерация начинается с 1. При указании формата, подразумевающего вывод данных и включая %n, номер увеличивается на 1.
%#<argn><fmt> устанавливает номер параметра в <argn> и далее отсчет ведется от него.
%( увеличивает номер, если проверка неуспешна. %| уменьшает номер параметра на 1 (т.е. конструкция %(d%d%|%s%) работает с 
автоматической нумерацией и позволяет использовать разное форматирование в зависимости от типа данных. 
В более сложных условных конструкциях может потребоваться явное указание параметра.
Если номер параметра указан явно, автоматическая нумерация продолжается с этого номера.
Например: "%x %u %#30X %d" использует номера параметров 1 2 30 31.
"%(d %d %| %s) %u" использует номера параметров 1 1 1 2
"%(d %d %| %#7s) %u" - 1 1 7 2 или 1 1 7 8 в зависимости от параметра 1. Чтобы зафиксировать номер последнего параметра,
нужно задать ему номер явно: "%(d %d %| %#7s) %#2u".

5.4 Ограничения logbuf_fmtauto_va
logbuf_fmtauto_va и функции, ее использующие (logbuf_simple_message, logbuf_debug, logbuf_fmtauto) определяют тип
параметров по строке формата. Поэтому в сокращенной форме перечисленные ниже варианты форматирования не допускаются.
- Условное форматирование %(
- %S
Поядок параметров должен соответствовать форматной строке, но изменение их номеров в буфере допускается.
Для массива используются 2 параметра - указатель и 32-битная длина.
Для %e указатель на массив из 6 байт.

6 Нумерация параметров в logbuf
Допустимые номера параметров - от 1 до 254. Значения 255 и 0 используются для параметров, которые
помещаются в буфер неявно. При поиске параметров logdest_get_arg значения 0 для типа или номера параметра понимает как "любой".
Использование одного номера для значений разных типов допускается.
Если в строке формата не используется автоматическая нумерация, то номера параметров не обязательно задавать последовательно.

