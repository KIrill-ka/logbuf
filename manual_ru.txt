Библиотека протоколирования событий logbuf

1. Составные части

1.1 logbuf (log buffer)
Содержит функции для сбора информации о событии и упаковки
этой информации. После упаковки параметры сообщения доступны по отдельности
то есть пригодны и для форматирования в читаемую пользователем строку и для
автоматического анализа/реации на событие.

1.2 logcounter (log counter)
Фильтрует сообщения на самом низком уровне,
обеспечивает передачу сообщений по одному или нескольким каналам.

1.3 logdest (log destination)
Вспомогательная библиотека для реализации способов доставки сообщений пользователю.
Включает функции форматирования сообщений из данных logbuf в читаемую строку.

1.4 logres (log resources)
Получение строк по идентификатору ресурса. Могут быть получены строки
для форматирования сообщений.

                       +-> LOGDEST1 --> SYSLOG
                      /
LOGBUF <-> LOGCOUNTER --> LOGDEST2 --> STDIO
                      \
                       +-> LOGDEST3 --> FILE
                             ^
                             |
                           LOGRES

2. Сценарии спользования

2.1 Простейшая схема использования почти не отличается от вывода сообщений в stdio.
Форматная строка непосредственно встраивается в сообщение, описывается 
простейший способ вывода сообщений в stdio. Ресурсы не используется.
Пример в test/logtest.c
Его можно еще немного упростить, если вместо раздельной передачи
параметров сообщения использовать logbuf_simple_message.

2.2 Использование ресурсов. К примеру 2.1 добавляем описание ресурсов -
форматная строка сообщения теперь содержится не в тексте программы, а в
ini-файле. В примере test/logtest-res.c для упрощения текст ini-файла
включен в текст программы. В качестве идентификатора ресурса используется 1.
При реальном использовании константы-идентификаторы ресурсов в формате #define 
могут быть получены с помощью скрипта scripts/ini2resid.awk

awk -f scripts/ini2resid.awk -v name=имя_заголовка имя_файла_ini > имя_заголовка

3. Основные особенности и свойства библиотек logbuf

Простота начального использования: если в программе потенциально может
понадобиться протоколирование событий, но пока достаточно только вывода
в stdio, библиотеки logbuf могут быть использованы. Далее, например,
при необходимости вывода сообщений в syslog или через GUI потребуются
минимальные переделки (в идеале код формирующий сообщения вообще не потребует
изменений). Форматные строки, добавляемые при формировании сообщения, 
могут быть заменены ресурсами. При этом оригинальные строки удалять не надо,
они просто перестанут использоваться.

Маска событий и фильтрация на нижнем уровне: при большой интенсивности
событий небоходима возможность оключения протоколирования. При отключенном
логе должно выполняться как можно меньше действий по формированию сообщений.
Это достигается путем задания маски сообщений. В logcounter задается 64-битная
маска, которая позволяет разбить сообщения на 64 группы, каждую из которых
можно индивидуально оключить. Маска задается индивидуально для каждого
канала передачи (log destination). Если ни для одного канала не требуются
сообщения какой-то группы, то формирования сообщения не начнется (logbuf_get
вернет NULL).
Источник сообщений может задать маску по-умолчанию (logcounter_set_default_filter) 
на случай, если получатель событий не знает, как управлять событиями из этого источника.

"Модульное" использование: если программа состоит из нескольких компонент/библиотек -
каждая из них создает свой logcounter. Далее библиотека предоставляет в своем
интерфейсе доступ к этому logcounter. Основная программа при старте связывает 
logcounter библиотек и получателей сообщений.
Файлы ресурсов могут быть разделены - ini-файл хранится рядом с кодом библиотеки.
Идентификаторы ресурсов должны быть уникальными - для этого старшие 12 бит кода
ресурса являются идентификатором модуля/библиотеки.
При сборке дистрибутива ini-файлы всех модулей моут быть объединены или включены
в дистрибутив и подгружены по-отдельности.

Timestamp: в logcounter предусмотрена функция задания временной метки для
события. Т.е. в каждом сообщении отмечается время его формирования. Это
может быть использовано для диагностики проблем, связанных с производительностью.
См. logcounter_tstamp_onoff.

4. log_stdio

log_stdio - готовый способ вывода сообщений в файлы stdio.
Например, чтобы сделать традиционный вывод в stderr и stdout, нужно
создать два экземпляра logdest:

log_err = logdest_stdio_create(stderr, NULL);
log_norm = logdest_stdio_create(stdout, NULL);

logcounter_connect(lc, log_err);
logcounter_connect(lc, log_norm);
logcounter_set_filter(lc, log_err, <error_mask>);
logcounter_set_filter(lc, log_norm, ~ <error_mask>);

5. Форматные строки

Строка, используемая для форматирования сообщения унаследована от системы ipsm/log (klogview).

5.1 Типы данных (dtype) - это то, что содержится в буфере до форматирования.
D - int64
s - string (8-bit)
S - format string (8-bit)
b - data buffer
d - int32
R - int32 - идентификатор ресурса

5.2 Форматы (после знака %)
d,x,u - целые числа, аналогично printf %d, %x, %u.
        Допустимые типы данных: D, d
a - IP-адрес.
        Допустимые типы данных: d
% - %
,<width><fmt> - массив данных (печатаются значения через пробел).
        Допустимые типы данных: b.
        <width> - размер элемента в байтах (1-8). Если <width> опущено, то 4.
        <fmt> - формат d,x,u,a. Если a - то <width> должно быть 4.
n - инорировать параметр
s - строка
        Допустимые типы данных: s, R
S - вложенная форматная строка (максимальный уровень вложенности 8)
        Допустимые типы данных: S, R
    
#<argn><fmt> - фиксированный номер параметра (<argn>)
        <fmt> - любой формат из описанных выше
(<argn><dtype> - условное форматирование. Если есть <argn> и его тип соответствует <dtype>, включается строка следующая
        после <dtype> до %). Вложение условий допускается.
        <argn> опциональный номер параметра для проверки. Если номер не указан, используется автонумерация.
        <dtype>  - тип данных (описаны выше). Если указана *, проверка на соответствие типа не производится,
        достаточно наличия аргумента.
| - используется как "else" в конструкции %( %| %). Если проверка %( не сработала, то включается строка, идущая между %| и %).

5.3 Автоматическая нумерация параметров
Нумерация начинается с 1. При указании формата, подразумевающего вывод данных и включая %n, номер увеличивается на 1.
%#<argn><fmt> устанавливает номер параметра в <argn> и далее отсчет ведется от него.
%( увеличивает номер, если проверка неуспешна. %| уменьшает номер параметра на 1 (т.е. конструкция %(d%d%|%s%) работает с 
автоматической нумерацией и позволяет использовать разное форматирование в зависимости от типа данных. 
В более сложных условных конструкциях может потребоваться явное указание параметра.

